import re
import os
import glob
import h5py
import yaml
import numpy as np
from tqdm import tqdm
from music21 import converter, note, chord, instrument, stream

def get_song_notes(path):
    """
    Returns all the notes/chords in a song.
    https://github.com/Skuldur/Classical-Piano-Composer
    :param path: Midi file path
    :return: Midi notes/chords
    """
    notes = []
    midi = converter.parse(path)
    try:
        parts = instrument.partitionByInstrument(midi)
        parsed_notes = parts.parts[0].recurse()
    except AttributeError:
        parsed_notes = midi.flat.notes

    for element in parsed_notes:
        if isinstance(element, note.Note):
            notes.append(str(element.pitch))
        elif isinstance(element, chord.Chord):
            notes.append('.'.join(str(n) for n in element.normalOrder))
    return np.array(notes)

def check_notes(config_file):
    """
    Used for determining number of unique notes and creation of hdf5 dataset.
    :param config_file: Configuration file
    :return: Hdf5 object containing both the unique notes and the notes per song.
    """
    def _encode(str_list):
        """
        Used for encoding utf-8 into ascii to store strings into hdf5.
        :param str_list:
        :return: ASCII encoded strings
        """
        return [s.encode('ascii', 'ignore') for s in str_list]

    with open(config_file, 'rb') as f:
        config = yaml.load(f, Loader=yaml.UnsafeLoader)

    out = os.path.join(config['out_path'], 'data')
    make_path(out)
    # Check if the config file has a 'note' dir
    if 'note_file' not in list(config.keys()):
        config['note_file'] = os.path.join(out, 'notes.h5')
        # Create hdf5 file
        h5 = h5py.File(config['note_file'])
        unique_notes = []
        # Check all the songs to process
        songs_to_process = get_song_paths(config)
        for song in tqdm(songs_to_process):
            # Per song get the name and notes
            song_name = song.split(os.sep)[-1]
            notes = get_song_notes(song)
            # Create the song instance on the hdf5 file
            unique_notes.append(notes)
            h5.create_dataset(song_name, data=_encode(notes))
        # Find all unique notes and encode
        unique_notes = [g for f in unique_notes for g in f]
        unique_notes = _encode(np.unique(unique_notes))
        h5.create_dataset('unique', data=unique_notes)

        # Update yaml
        with open(config_file, 'w') as f:
            yaml.dump(config, f, Dumper=yaml.SafeDumper)
    else:
        # If note files exist load and pass
        h5 = h5py.File(config['note_file'])
    return h5

def make_path(path):
    """
    Check if path exists, if not make it
    :param path:
    :return:
    """
    if not os.path.exists(path):
        os.makedirs(path)

def get_song_paths(config):
    """
    Return all paths of midi files
    :param config:
    :return:
    """
    return glob.glob(os.path.join(config['data_path'], '*.mid'))

def get_target_ckpt(dir_path, epoch):
    """
    Load a specific checkpoint.
    :param dir_path:
    :param epoch:
    :return:
    """
    latest_id = []
    for ckpt_name in os.listdir(dir_path):
        latest_id.append(re.match(
            re.compile('epoch_(\d+).pth'), ckpt_name).group(1))
    return dir_path + os.sep + 'epoch_' + str(epoch) + '.pth'

def get_latest_ckpt(dir_path):
    """
    Load the latest checkpoint.
    :param dir_path:
    :return:
    """
    latest_id = []
    for ckpt_name in os.listdir(dir_path):
        latest_id.append(re.match(
            re.compile('epoch_(\d+).pth'), ckpt_name).group(1))
    latest_id = max([int(x) for x in latest_id])
    return dir_path + os.sep + 'epoch_' + str(latest_id) + '.pth'

def create_midi(prediction_output):
    """
    Create a midi file from a series of network predictions.
    Original: https://github.com/Skuldur/Classical-Piano-Composer
    :param prediction_output:
    :return:
    """
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 0.5

    midi_stream = stream.Stream(output_notes)
    return midi_stream

if __name__ == '__main__':
    check_notes('/home/rimbriaco/PycharmProjects/rnn_music/configs/std_config.yaml')